# IO

### Linux 文件系统是怎么工作的？

##### 索引节点和目录项

Linux 文件系统为每个文件都分配两个数据结构，索引节点（index node）和目录项（directory entry）。它们主要用来记录文件的元信息和目录结构。索引节点是每个文件的唯一标志，而目录项维护的正是文件系统的树状结构。目录项和索引节点的关系是多对一，一个文件可以有多个别名

* 索引节点，简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。索引节点同样占用磁盘空间
* 目录项，简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存

磁盘读写的最小单位是扇区，然而扇区只有 512B 大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，由连续的 8 个扇区组成

![img](https://static001.geekbang.org/resource/image/32/47/328d942a38230a973f11bae67307be47.png)

超级块：存储整个文件系统的状态。索引节点区：存储索引节点。数据块区：存储文件数据

##### 虚拟文件系统

目录项、索引节点、逻辑块以及超级块，构成了 Linux 文件系统的四大基本要素。为了支持各种不同的文件系统，Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层：虚拟文件系统 VFS（Virtual File System）

![img](https://static001.geekbang.org/resource/image/72/12/728b7b39252a1e23a7a223cdf4aa1612.png)

文件系统可以分为三类：

* 第一类是基于磁盘的文件系统：把数据直接存储在计算机本地挂载的磁盘中。常见的 Ext4、XFS、OverlayFS 等，都是这类文件系统
* 第二类是基于内存的文件系统：虚拟文件系统。不需要任何磁盘分配存储空间，但会占用内存。/proc 文件系统，就是一种最常见的虚拟文件系统。/sys 文件系统也属于这一类，主要向用户空间导出层次化的内核对象
* 第三类是网络文件系统：用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等

这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为挂载点），然后才能访问其中的文件

##### 文件系统 I/O

把文件系统挂载到挂载点后，就能通过挂载点，再去访问它管理的文件了。VFS 提供了一组标准的文件访问接口。文件读写方式的各种差异，导致 I/O 的分类多种多样。最常见的有四种：

* 第一种，根据是否利用标准库缓存，分为：
  * 缓冲 I/O，是指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调度访问文件
  * 非缓冲 I/O，是指直接通过系统调用来访问文件，不再经过标准库缓存

“缓冲”，是指标准库内部实现的缓存，无论缓冲 I/O 还是非缓冲 I/O，它们最终还是要经过系统调用来访问文件。系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作

* 第二种，据是否利用操作系统的页缓存，分为：
  * 直接 I/O，是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件
  * 非直接 I/O 正好相反，文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正写入磁盘

实现直接 I/O，需要在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是非直接 I/O。直接 I/O、非直接 I/O，本质上还是和文件系统交互。如果是在数据库等场景中，跳过文件系统读写磁盘的情况，也就是通常所说的裸 I/O

* 第三种，根据应用程序是否阻塞自身运行，分为：
  * 阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程
  * 非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果

访问管道或者网络套接字时，设置 O_NONBLOCK 标志，表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问

* 第四种，根据是否等待响应结果，分为：
  * 同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应
  * 异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序

在操作文件时，如果设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写

##### 性能观测

查看容量

```
$ df -h /dev/sda1 
Filesystem      Size  Used Avail Use% Mounted on 
/dev/sda1        29G  3.1G   26G  11% / 

// -i 可以查看索引节点的使用情况，索引节点空间不足，但磁盘空间充足时，很可能就是过多小文件导致的
$ df -i /dev/sda1 
Filesystem      Inodes  IUsed   IFree IUse% Mounted on 
/dev/sda1      3870720 157460 3713260    5% / 
```

查看缓存

```
// free 输出的 Cache，是页缓存和可回收 Slab 缓存的和，可以从 /proc/meminfo ，直接得到它们的大小

$ cat /proc/meminfo | grep -E "SReclaimable|Cached" 
Cached:           748316 kB 
SwapCached:            0 kB 
SReclaimable:     179508 kB 

内核使用 Slab 机制，管理目录项和索引节点的缓存。/proc/meminfo 只给出了 Slab 的整体大小，具体到每一种 Slab 缓存，还要查看 /proc/slabinfo 这个文件

// 查看所有目录项和各种文件系统索引节点的缓存情况
$ cat /proc/slabinfo | grep -E '^#|dentry|inode' 
# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> : tunables <limit> <batchcount> <sharedfactor> : slabdata <active_slabs> <num_slabs> <sharedavail> 
xfs_inode              0      0    960   17    4 : tunables    0    0    0 : slabdata      0      0      0 
... 
ext4_inode_cache   32104  34590   1088   15    4 : tunables    0    0    0 : slabdata   2306   2306      0hugetlbfs_inode_cache     13     13    624   13    2 : tunables    0    0    0 : slabdata      1      1      0 
sock_inode_cache    1190   1242    704   23    4 : tunables    0    0    0 : slabdata     54     54      0 
shmem_inode_cache   1622   2139    712   23    4 : tunables    0    0    0 : slabdata     93     93      0 
proc_inode_cache    3560   4080    680   12    2 : tunables    0    0    0 : slabdata    340    340      0 
inode_cache        25172  25818    608   13    2 : tunables    0    0    0 : slabdata   1986   1986      0 
dentry             76050 121296    192   21    1 : tunables    0    0    0 : slabdata   5776   5776      0 

dentry 行表示目录项缓存，inode_cache 行，表示 VFS 索引节点缓存，其余的则是各种文件系统的索引节点缓存
实际性能分析中，更常使用 slabtop  ，来找到占用内存最多的缓存类型

# 按下c按照缓存大小排序，按下a按照活跃对象数排序 
$ slabtop 
Active / Total Objects (% used)    : 277970 / 358914 (77.4%) 
Active / Total Slabs (% used)      : 12414 / 12414 (100.0%) 
Active / Total Caches (% used)     : 83 / 135 (61.5%) 
Active / Total Size (% used)       : 57816.88K / 73307.70K (78.9%) 
Minimum / Average / Maximum Object : 0.01K / 0.20K / 22.88K 

  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME 
69804  23094   0%    0.19K   3324       21     13296K dentry 
16380  15854   0%    0.59K   1260       13     10080K inode_cache 
58260  55397   0%    0.13K   1942       30      7768K kernfs_node_cache 
   485    413   0%    5.69K     97        5      3104K task_struct 
  1472   1397   0%    2.00K     92       16      2944K kmalloc-2048 
  
目录项dentry和索引节点inode_cache占用了最多的 Slab 缓存。不过加起来也只有 23MB 左右  
```

### Linux 磁盘I/O是怎么工作的

##### 磁盘

磁盘是可以持久化存储的设备，根据存储介质的不同，常见磁盘可以分为两类：

* 机械磁盘（Hard Disk Driver）：也称为硬盘驱动器，缩写为 HDD。主要由盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。最小读写单位是扇区，一般大小为 512 字节
* 固态磁盘（Solid State Disk）：缩写为 SSD，由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。最小读写单位是页，通常大小是 4KB、8KB 等

按照接口来分类，可以把硬盘分为：

* IDE（Integrated Drive Electronics）
* SCSI（Small Computer System Interface） 
* SAS（Serial Attached SCSI） 
* SATA（Serial ATA） 
* FC（Fibre Channel） 等

不同的接口，往往分配不同的设备名称。比如， IDE 设备会分配一个 hd 前缀的设备名，SCSI 和 SATA 设备会分配一个 sd 前缀的设备名。如果是多块同类型的磁盘，就会按照 a、b、c 等的字母顺序来编号。作为独立磁盘设备来使用。磁盘还会根据需要，划分为不同的逻辑分区，每个分区再用数字编号。比如 /dev/sda ，可以分成两个分区 /dev/sda1 和 /dev/sda2

一个比较常用的架构，是把多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列，也就是 RAID（Redundant Array of Independent Disks），从而可以提高数据访问的性能，并且增强数据存储的可靠性

在 Linux 中，磁盘实际上是作为一个块设备来管理的，也就是以块为单位读写数据，并且支持随机读写。每个块设备都会被赋予两个设备号，主设备号用在驱动程序中，用来区分设备类型；而次设备号则是用来给多个同类设备编号

##### 通用块层

其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。它主要有两个功能 ：

* 第一个功能跟虚拟文件系统的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序
* 第二个功能，通用块层还会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率

对 I/O 请求排序的过程，也就是我们熟悉的 I/O 调度。事实上，Linux 内核支持四种 I/O 调度算法：

* 第一种 NONE ，完全不使用任何 I/O 调度器，常用在虚拟机中（此时磁盘 I/O 调度完全由物理机负责）
* 第二种 NOOP ，是一个先入先出的队列，只做一些最基本的请求合并，常用于 SSD 磁盘
* 第三种 CFQ（Completely Fair Scheduler），也被称为完全公平调度器，是现在很多发行版的默认 I/O 调度器，它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求
* 第四种DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理。多用在 I/O 压力比较重的场景，比如数据库等

##### I/O 栈

把 Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。这三个 I/O 层的关系如下图所示，这也是 Linux 存储系统的 I/O 栈全景图

![img](https://static001.geekbang.org/resource/image/14/b1/14bc3d26efe093d3eada173f869146b1.png)

根据这张 I/O 栈的全景图，存储系统 I/O 的工作原理：

* 文件系统层：包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据
* 通用块层：包括块设备 I/O 队列和 I/O 调度器。向上为文件系统和应用程序，提供访问了块设备的标准接口；向下把各种异构的磁盘设备，抽象为统一的块设备，并会对文件系统和应用程序发来的 I/O 请求，进行重新排序、请求合并等，提高了磁盘访问的效率
* 设备层：包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作

##### 磁盘性能指标

* 使用率：磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。当使用率是 100% 的时候，磁盘依然有可能接受新的 I/O 请求
* 饱和度：磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求
* IOPS（Input/Output Per Second）：每秒的 I/O 请求数
* 吞吐量：每秒的 I/O 请求大小
* 响应时间： I/O 请求从发出到收到响应的间隔时间

分析工具：

- fio：测试磁盘的 IOPS、吞吐量以及响应时间等核心指标

需要测试出，不同 I/O 大小（一般是 512B 至 1MB 中间的若干值）分别在随机读、顺序读、随机写、顺序写等各种场景下的性能情况。用性能工具得到的这些指标，可以作为后续分析应用程序性能的依据。一旦发生性能问题，你就可以把它们作为磁盘性能的极限值，进而评估磁盘 I/O 的使用情况

##### 磁盘IO观测

分析工具：

* iostat：提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，这些指标实际上来自  /proc/diskstats

![img](https://static001.geekbang.org/resource/image/cf/8d/cff31e715af51c9cb8085ce1bb48318d.png)

其中：

* %util ：磁盘 I/O 使用率
* r/s+  w/s：IOPS
* rkB/s+wkB/s ：吞吐量
* r_await+w_await ：响应时间

饱和度通常也没有其他简单的观测方法，不过可以把观测到的，平均请求队列长度或者读写请求完成的等待时间，跟基准测试的结果（比如通过 fio）进行对比，综合评估磁盘的饱和情况

##### 进程 I/O 观测

iostat 只提供磁盘整体的 I/O 性能数据，要观察进程的 I/O 情况，可以使用 pidstat 和 iotop 这两个工具

```

$ pidstat -d 1 
13:39:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command 
13:39:52      102       916      0.00      4.00      0.00       0  rsyslogd

用户 ID（UID）和进程 ID（PID）
每秒读取的数据大小（kB_rd/s） ，单位是 KB
每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB
每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB
块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期
```

分析工具：

* iotop：一个类似于 top 的工具，可以按照 I/O 大小对进程排序，然后找到 I/O 较大的那些进程

```
$ iotop
Total DISK READ :       0.00 B/s | Total DISK WRITE :       7.85 K/s 
Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s 
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND 
15055 be/3 root        0.00 B/s    7.85 K/s  0.00 %  0.00 % systemd-journald 

前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。因为缓存、缓冲区、I/O 合并等因素的影响，它们可能并不相等

线程 ID
I/O 优先级
每秒读磁盘的大小
每秒写磁盘的大小
换入和等待 I/O 的时钟百分比等
```

