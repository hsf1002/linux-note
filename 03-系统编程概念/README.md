### 第3章 系统编程概念

##### 系统调用

只要执行系统调用或者库函数，检查返回状态以确定调用是否成功，是编程的一条铁律

系统调用与库函数很像，其幕后会经历诸多步骤：

1. 通过调用C语言库函数的外壳函数，发起系统调用
2. 对系统调用中断处理例程来说，外壳函数必须保证所有的系统调用参数可用
3. 内核需要区分每个系统调用，将系统编号复制到一个特殊的寄存器
4. 外壳函数执行一条中断指令int 0x80，引发处理器从用户态切到核心态，并执行系统中断0x80的中断矢量所指向的代码
5. 为了响应中断0x80，内核会调用system_call来处理这次中断
   * 内核栈中保存寄存器
   * 审核系统调用编号的有效性
   * 以系统调用编号存放所有调用服务的列表（内核变量sys_call_table）进行索引，发现并调用相应的系统服务
   * 从内核栈中恢复各个寄存器，将系统调用返回值放在栈中
   * 返回外壳函数，同时将处理器切回用户态
6. 若系统调用例程的返回值表明调用有误，外壳函数使用该值设置全局变量errno，然后外壳函数返回到调用程序，同时返回一个整型值，表明系统调用是否成功

一个简单的系统调用，也要完成相当多的工作，因此系统调用开销虽小，却不容忽视

##### 库函数

许多库函数不会使用任何系统调用，有些库函数构建于系统调用层之上，比如fopen利用open来执行打开文件的实际操作，又如printf相对于write，设计库函数为了提供比底层更为方便的调用接口

##### 标准C语言函数库：glibc

确定系统的glibc版本：

```
/lib/libc.so.6
```

发现glic共享库的路径：

```
ldd prog | grep libc
```

##### 处理系统调用和库函数的错误

不检查状态值，少敲几个字，听起来很诱人，却得不偿失，除了少数几个系统调用从不失败，如getpid总能返回进程id，_exit总能终止进程，绝大多数系统调用和库函数都应该检查返回值以确认是否调用成功

* 系统调用失败时，会将errno设置为一个正值，以标识具体的错误

* 进行错误检查时，应该首先检查函数的返回值是否调用出错，再检查errno确定错误原因

* 少数系统调用即使成功，也返回-1如getpriority，要判断此类系统调用，应在调用前将errno设置为0，并在调用后对其检查

* perror会打印msg所指向的字符串，紧跟一条与当前errno值相对应的消息

  ```
  #include <stdio.h>
  void perror(const char *msg);
  
  if (-1 == (fd = (open(pathname, flags, mode))))
  {
  	perror("open");
  	exit(EXIT_FAILURE);
  } 
  ```

* strerror会针对errnum指定的错误号，返回相应的字符串

  ```
  #include <string.h>
  char *strerror(int errnum);
  ```

处理库函数的错误：

* 某些库函数返回错误信息的方式与系统调用完全相同，返回值为-1，以errno标识具体错误，如remove
* 某些库函数出错会返回-1之外的其他值，仍会设置errno标识具体错误，如fopen，此类可用perror和stderr诊断
* 还有些库函数根本不使用errno，此类不可用perror和stderr诊断

