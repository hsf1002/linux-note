## 第38章 编写安全的特权程序

### 是否需要一个set-user-id或set-group-id程序

一个程序可以通过两种方式以特权方式运行：

* 程序在特权用户ID下启动，很多daemon程序都是以root身份启动并运行
* 程序设置了set-user-ID或set-group-ID权限位，当此程序被执行时，它会将进程的有效用户ID（组）修改为程序的所有者（组）

尽量避免编写此类程序

假如一个set-user-ID程序需要更新一个它没有写权限的程序，更加安全的方式是创建一个专用组账号（组ID），将文件所属的组修改为那个组，接着编写一个将进程的有效组ID设置为该专用组ID的set-user-ID程序，由于这个专用组ID没有其他权限位，能够极大的限制程序包含bug或被破坏时造成的损失

### 以最小权限操作

##### 按需拥有权限

```
uid_t orig_euid;

orig_euid = geteuid();
// 放弃权限：将有效用户ID改为真实用户ID
if (-1 == seteuid(getuid()))
    perror("seteuid error");
// 重获权限：将有效用户ID还原为saved set-user-ID
    if (-1 == seteuid(orig_euid))
perror("seteuid error");
```

最安全的做法是在程序启动的时候立刻删除权限，后面需要的时候临时重新获取权限

##### 无需使用时永久的删除权限

通过将进程用户（组）ID重置为真实（组）ID完成

##### 修改进程身份信息的注意事项

* Linux上，使用setresuid、setresgid修改用户和组身份信息
* 即使调用者的有效用户ID为0，修改身份信息的系统调用在程序显式的操作其能力时可能表现出意料之外的行为，如禁用CAP_SETUID能力，修改进程用户ID将失败
* 实践中，不仅要检查修改身份信息的系统调用是否成功，还需验证修改行为是否达到预期
* 一些身份信息的变更只能由有效用户ID为0的进程完成

### 小心执行程序

##### 在执行另一个程序前永久的删除权限

如果一个set-user-ID程序执行了另一个程序，那么应该确保进程用户（组）ID被重置为真实用户（组）ID，这样新程序在启动时就不会拥有这些权限

##### 避免执行一个拥有权限的shell

运行于用户控制下的特权程序不应该直接或间接的执行shell，shell的复杂性和强大功能几乎不可能消除所有的安全漏洞，如果必须要执行shell，需确保执行之前永久的删除权限，Linux中，执行脚本时会毫无征兆的忽略set-user-ID和set-group-ID权限位

##### 在exec之前关闭用不到的文件描述符

可以显式的关闭或设置close-on-exec标记

### 避免暴露敏感信息

当程序读取密码或其他敏感信息时应该执行完所需的处理后立刻从内存删除这些信息，这种安全隐患的原因：

* 包含这些数据的虚拟内存页面可能被一个特权程序读取
* 如果产生core文件，可能从该文件读取

应该避免产生core文件，默认Linux中，不允许set-user-ID程序收到信号时产生一个core

