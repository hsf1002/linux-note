# linux性能优化



![img](https://static001.geekbang.org/resource/image/9e/7a/9ee6c1c5d88b0468af1a3280865a6b7a.png)



![img](https://static001.geekbang.org/resource/image/0f/ba/0faf56cd9521e665f739b03dd04470ba.png)

## CPU性能篇

### 到底应该怎么理解平均负载？

```
13:11  up 124 days, 3 users, load averages: 1.99 2.10 2.33
当前时间  系统登录时长  登录账户个数  1、5、15分钟CPU的平均负载
```

##### 平均负载

指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系

* 可运行状态的进程：正在使用 CPU 或者正在等待 CPU 的进程，ps 命令看到的处于 R 状态（Running 或 Runnable）的进程
* 不可中断状态的进程：正处于内核态关键流程中的进程，不可被打断，比如最常见的是等待硬件设备的 I/O 响应， ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程，不可中断状态实际上是系统对进程和硬件设备的一种保护机制

最理想的是每个 CPU 上都刚好运行着一个进程，每个 CPU 都得到充分利用。当平均负载为 2 时，意味着：

* 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用
* 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲
* 在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU

##### 平均负载为多少时合理

查看本机CPU数量：

```
grep 'model name' /proc/cpuinfo | wc -l
4
```

1、5、15分钟的平均负载，提供了分析系统负载趋势的数据来源，可以更全面、更立体地理解目前的负载状况，当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了

##### 平均负载与 CPU 使用率

平均负载不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：

* CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时两者是一致的
* I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高
* 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高

##### 平均负载案例分析

```
apt install stress sysstat
```

* stress：一个 Linux 系统压力测试工具，用作异常进程模拟平均负载升高的场景

* sysstat：包含了常用的 Linux 性能工具，用来监控和分析系统的性能。这个包的两个命令 mpstat 和 pidstat
  * mpstat：一个常用的多核 CPU 性能分析工具，可实时查看每个 CPU 的性能指标以及所有 CPU 的平均指标
  * pidstat：一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标

场景一：CPU  密集型进程

```
// 第一个终端运行  stress  命令，模拟一个  CPU  使用率 100% 的场景
stress --cpu 1 --timeout 600

// 第二个终端运行 uptime 查看平均负载的变化情况
// -d 参数表示高亮显示变化的区域
watch -d uptime

// 第三个终端运行 mpstat 查看  CPU  使用率的变化情况
// -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
mpstat -P ALL 5

平均负载的升高正是由于 CPU 使用率为 100% 

// 哪个进程导致了 CPU 使用率为 100% ？可以使用 pidstat 来查询
// 间隔5秒后输出一组数据
pidstat -u 5 1
```

场景二：I/O  密集型进程

```
// 第一个终端运行  stress  命令，但这次模拟  I/O  压力，即不停地执行  sync
stress -i 1 --timeout 600

// 第二个终端运行 uptime 查看平均负载的变化情况
watch -d uptime

// 第三个终端运行 mpstat 查看  CPU  使用率的变化情况
mpstat -P ALL 5

平均负载的升高正是由于 IO 使用率为 90% 

// 哪个进程导致了 IO 使用率为 90% ？可以使用 pidstat 来查询
pidstat -u 5 1
```

场景三：大量进程的场景

```
// 第一个终端运行  stress  命令，模拟创建了16个进程
stress -c 16 --timeout 600
 
// 第二个终端运行 uptime 查看平均负载的变化情况， 系统只有 4 个 CPU，明显比 16 个进程要少得多，因而，系统的 CPU 处于严重过载状态
watch -d uptime

// 第三个终端查看哪个进程占用资源，发现有16个进程分布在4个CPU上
pidstat -u 5 1
```

### 经常说的 CPU 上下文切换是什么意思？

##### CPU 上下文

用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文

##### CPU 上下文切换

先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。根据任务的不同，CPU 的上下文切换可以分为几个不同的场景，进程上下文切换、线程上下文切换以及中断上下文切换

##### 进程上下文切换

从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，调用 read() 读取文件内容，调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

* 进程上下文切换：从一个进程切换到另一个进程运行，进程的切换只能发生在内核态，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间，这个时间相当可观
* 系统调用：一直是同一个进程在运行。通常称为特权模式切换，而不是上下文切换。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的

进程切换时才需要切换上下文，进程切换的原因：

* CPU时间片到了
* 系统资源不足导致进程被挂起
* 通过睡眠函数  sleep 这样的方法将自己主动挂起时
* 有优先级更高的进程运行时
* 发生硬件中断时

##### 线程上下文切换

线程与进程最大的区别在于，线程是调度的基本单位，而进程则是资源拥有的基本单位。所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源

* 当进程只有一个线程时，可以认为进程就等于线程
* 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的
* 线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的

线程的上下文切换其实就可以分为两种情况：

* 第一种： 前后两个线程属于不同进程。因为资源不共享，所以切换过程就跟进程上下文切换是一样
* 第二种：前后两个线程属于同一个进程。因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据

虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源

##### 中断上下文切换

中断处理会打断进程的正常调度和执行，转而调用中断处理程序。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。跟进程上下文不同，中断上下文切换并不涉及到进程的用户态，所以无需保存其用户态资源，只需要保存内核态中断服务程序执行所必需的状态。对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。大部分中断处理程序都短小精悍，以便尽可能快的执行结束。跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能

* CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要特别关注
* 过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降

