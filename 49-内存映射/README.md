## 第49章 内存映射

### 概述

映射分为两种：

* 文件映射：将一个文件的一部分或全部映射到调用进程的虚拟内存中，就可以通过在内存区操作来访问文件内容了
* 匿名映射：没有对应的文件，映射的分页被初始化为0

映射的类型：

* 私有映射：映射内容发生的变更对其他进程不可见，对于文件映射来说，变更将不会在底层文件上进行
* 共享映射：映射内容发生的变更对所有共享同一映射的其他进程都可见，对于文件映射来说，变更将会在底层文件上进行

可细分为四种：

* 私有文件映射：映射内存初始化为文件的内容，主要用途是使用一个文件的内容初始化一块内存
* 私有匿名映射：每次调用mmap都会创建一个与其他匿名映射不同的新映射（映射不会共享物理分页），主要为一个进程分配新内存（用零填充）
* 共享文件映射：所有映射一个文件同一区域的进程共享同样的内存物理分页，两个用途：允许内存映射IO，一个文件被加载到进程虚拟内存的一个区域并且对这块内容的更改自动写到这个文件；允许无关进程共享一块内容以便以一种类似System V共享内存的方式执行IPC
* 共享匿名映射：每次调用mmap都会创建一个与其他匿名映射不同的新映射（映射不会共享物理分页），它允许以一种类似System V 共享内存的方式进行IPC，但只有相关进程可以这样做

进程在执行exec时映射会丢失，通过fork后的子进程会继承映射，映射类型也会继承

通过Linux特有的/proc/PID/maps能够查看一个进程的映射信息

### 创建一个映射

在调用进程的虚拟空间创建一个新映射：

```
#include <sys/mmap.h>

void *mmap(void *addr, size_t len, int prot, int flag, int fd, off_t offset);
// 若成功，返回映射起始地址，若出错，返回MAP_FAILED
// addr为NULL，内核自动选择一个合适的地址，这是推荐的可移植的做法
// len指定了映射的字节数
// prot的取值（一个进程若在访问时违反了保护位，内核产生SIGSEGV信号）：
PROT_NONE: 区域内容无法访问
PROT_READ: 区域内容可读
PROT_WRITE: 区域内容可写
PROT_EXEC: 区域内容可执行
// flag的取值：
MAP_PRIVATE: 私有映射，区域内内容发生的变更对使用同一映射的其他进程不可见，对文件映射，变更不会反应在底层文件
MAP_SHARED: 共享映射，区域内内容发生的变更对使用同一映射的其他进程可见，对文件映射，变更会反应在底层文件
// fd和offset用于文件映射，标识被映射的文件和偏移（是系统分页大小的倍数），映射整个文件，将offset指定为0且len为文件大小
```

### 解除映射区域

从调用进程虚拟地址空间删除一个映射：

```
int munmap(void *addr, size_t len);
// 若成功，返回0，若出错，返回-1
// addr是待解除映射的起始地址
// len是待解除映射区域大小，可以解除一个映射中的部分映射，原来的映射要么收缩，要么被分成两部分
// addr和len指定的地址范围如果不存在映射，则调用不起作用，但返回0
```

解除映射期间，内核会删除进程持有的指定地址空间范围内的所有内存锁（mlock或mlockall建立）

进程终止或执行了exec之后进程中所有的映射会自动被解除

为确保一个共享文件映射的内容被写入到底层文件，使用munmap解除映射之前需要调用msync



