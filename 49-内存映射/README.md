## 第49章 内存映射

### 概述

映射分为两种：

* 文件映射：将一个文件的一部分或全部映射到调用进程的虚拟内存中，就可以通过在内存区操作来访问文件内容了
* 匿名映射：没有对应的文件，映射的分页被初始化为0

映射的类型：

* 私有映射：映射内容发生的变更对其他进程不可见，对于文件映射来说，变更将不会在底层文件上进行
* 共享映射：映射内容发生的变更对所有共享同一映射的其他进程都可见，对于文件映射来说，变更将会在底层文件上进行

可细分为四种：

* 私有文件映射：映射内存初始化为文件的内容，主要用途是使用一个文件的内容初始化一块内存
* 私有匿名映射：每次调用mmap都会创建一个与其他匿名映射不同的新映射（映射不会共享物理分页），主要为一个进程分配新内存（用零填充）
* 共享文件映射：所有映射一个文件同一区域的进程共享同样的内存物理分页，两个用途：允许内存映射IO，一个文件被加载到进程虚拟内存的一个区域并且对这块内容的更改自动写到这个文件；允许无关进程共享一块内容以便以一种类似System V共享内存的方式执行IPC
* 共享匿名映射：每次调用mmap都会创建一个与其他匿名映射不同的新映射（映射不会共享物理分页），它允许以一种类似System V 共享内存的方式进行IPC，但只有相关进程可以这样做

进程在执行exec时映射会丢失，通过fork后的子进程会继承映射，映射类型也会继承

通过Linux特有的/proc/PID/maps能够查看一个进程的映射信息

### 创建一个映射

在调用进程的虚拟空间创建一个新映射：

```
#include <sys/mmap.h>

void *mmap(void *addr, size_t len, int prot, int flag, int fd, off_t offset);
// 若成功，返回映射起始地址，若出错，返回MAP_FAILED
// addr为NULL，内核自动选择一个合适的地址，这是推荐的可移植的做法
// len指定了映射的字节数
// prot的取值（一个进程若在访问时违反了保护位，内核产生SIGSEGV信号）：
PROT_NONE: 区域内容无法访问
PROT_READ: 区域内容可读
PROT_WRITE: 区域内容可写
PROT_EXEC: 区域内容可执行
// flag的取值：
MAP_PRIVATE: 私有映射，区域内内容发生的变更对使用同一映射的其他进程不可见，对文件映射，变更不会反应在底层文件
MAP_SHARED: 共享映射，区域内内容发生的变更对使用同一映射的其他进程可见，对文件映射，变更会反应在底层文件
// fd和offset用于文件映射，标识被映射的文件和偏移（是系统分页大小的倍数），映射整个文件，将offset指定为0且len为文件大小
```

### 解除映射区域

从调用进程虚拟地址空间删除一个映射：

```
int munmap(void *addr, size_t len);
// 若成功，返回0，若出错，返回-1
// addr是待解除映射的起始地址
// len是待解除映射区域大小，可以解除一个映射中的部分映射，原来的映射要么收缩，要么被分成两部分
// addr和len指定的地址范围如果不存在映射，则调用不起作用，但返回0
```

解除映射期间，内核会删除进程持有的指定地址空间范围内的所有内存锁（mlock或mlockall建立）

进程终止或执行了exec之后进程中所有的映射会自动被解除

为确保一个共享文件映射的内容被写入到底层文件，使用munmap解除映射之前需要调用msync

### 文件映射

![WechatIMG44.jpeg](https://i.loli.net/2020/02/05/mefhoFbn7ajuwPt.jpg)

##### 私有文件映射

常见用途：

1. 允许多个执行同一程序或使用同一共享库的进程共享同样的文本段，它从底层可执行文件或库文件的相应部分映射而来
2. 映射一个可执行文件或共享库的初始化数据段，会被处理成私有使得对映射数据段内容的变更不会发生在底层文件

##### 共享文件映射

![WechatIMG45.jpeg](https://i.loli.net/2020/02/05/jveZnKwhOHfWQ1x.jpg)

两个用途：

1. 内存映射IO：通过访问内存的字节执行文件IO，依靠内核确保对内存的变更被传递到映射文件上，是使用read和write进行IO的替代方案

   优势：

   * 简化一些逻辑
   * 某些情况下，可以提升性能，原因：read/write需要两次传输，一次是文件和内核高速缓冲区之间，一次是高速缓冲区和用户缓冲区之间，使用mmap是直接将内存数据写到文件中，这种性能提升在大型文件重复随机访问时最有可能体现出来

   劣势：

   * 对于小数量IO，内存映射IO的开销（映射、分页故障、解除映射即更新硬件内存管理单元的超前转换缓冲器）比简单的read/write要大

2. IPC：与System V共享内存对象之间的区别是区域上内容的变更会反应到底层的映射文件上，这种特性对于那些需要共享内存内容在应用程序或系统重启时能够持久化的应用程序非常有用

##### 边界情况

试图访问映射结尾之外的字节导致SIGSEGV信号

创建一个大小超过底层文件大小的映射可能是无意义的，但通过扩展文件的方法（write或ftruncate）可以使得这种映射之前不可访问的部分变得可用

### 同步映射区域：msync

内核自动将发生在MAP_SHARED映射内容的变更写入底层文件，但默认内核不会保证同步何时发生，可手动同步：

```
int msync(void *addr, size_t len, int flag);
// 若成功，返回0，若出错，返回-1
// addr和len指定了需同步的起始地址和大小
// flag的取值：
MS_SYNC: 同步写入，阻塞直到所有修改被写入磁盘
MS_ASYNC: 异步写入，仅与内核高速缓冲区同步，会在将来某个时刻写入磁盘（由pdflush内核线程执行）
MS_INVALIDTE: 使得映射数据的缓存副本失效
```

