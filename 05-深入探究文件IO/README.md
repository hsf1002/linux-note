### 第5章 深入探究文件IO

##### 原子操作和竞争条件

竞争状态是这样一种情形：操作共享资源的两个进程或线程，其结果取决于一个无法预期的顺序

同时指定O_EXCL与O_CREATE时，如果要打开的文件已经存在，返回一个错误，这提供了一种机制：保证进程是打开文件的创建者，对文件是否存在的检查和创建文件属于同一原子操作

多进程同时向一个文件尾部添加数据，要规避竞争状态，需要将文件偏移量的移动和数据写入纳入同一原子操作，在打开文件时加入O_APPEND标志可以保证这点

##### 打开文件的状态标志

fcntl的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志，如

```
int flags;
int access_mode;

if (-1 == (flags = fcntl(fd, F_GETFL)))
	perror("fcntl get error");
if (flags & O_SYNC)
	printf("write are synchronized");
```

判断文件模式稍微复杂：

```
access_mode = flags & O_ACCMODE;
if (access_mode == O_WRONLY || access_mode == O_RDWR)
	printf("file is writtable");
```

修改文件的状态标志，适用于以下场景：

* 文件不是由调用程序打开，所以程序也无法使用open来控制文件的状态标志
* 文件描述符的获取是通过open之外的系统调用，如pipe或socket

添加O_APPEND标志：

```
flags |= O_APPEND;
if (-1 == fcntl(fd, F_SETFL, flags))
	perror("fcntl set error");
```

##### 文件描述符和打开文件之间的关系

多个文件描述符指向同一个打开文件，既有可能，也属必要，这些文件描述符可能在相同或不同的进程中打开，由内核维护的3个数据结构：

1. 进程级的文件描述符表
   * 控制文件描述符操作的一组标志，目前仅有close-on-exec
   * 对打开文件句柄的引用
2. 系统级的打开文件表
   * 当前文件的偏移量
   * 打开文件使用的状态标记
   * 文件访问模式
   * 与信号驱动IO相关的设置
   * 对该文件i-node对象的引用
3. 文件系统的i-node表
   * 文件类型和访问权限
   * 一个指针，指向该文件所持有的锁的列表
   * 文件的各种属性，包括文件大小和不同类型操作相关的时间戳

*** 进程A中的文件描述符1和20都指向同一个打开的文件句柄，可能是通过dup、dup2、fcntl形成的

*** 进程A中的文件描述符2和进程B中的文件描述符2都指向同一个打开的文件句柄，可能是fork后出现，也可能是当一个进程进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程

*** 进程A的文件描述符0和进程B的文件描述符3分别指向不同的文件句柄，但这些句柄都指向同一个i-node，即指向同一个文件，这是因为每个进程各自对同一个文件发起了open调用，同一个进程打开文件两次，也会发生

上述讨论揭示了以下要点：

* 两个不同的文件描述符，若指向同一个文件句柄，将共享同一个文件偏移量，如果其中一个通过read、write、lseek修改了文件偏移量，另一个文件描述符也会观察到这一变化，不管这两个文件描述符是属于同一进程还是不同进程
* 获取和修改打开的文件标志（如O_APPEND、O_NONBLOCK）可执行fcntl的F_GETFL和G_SETFL，作用域类似上面
* 而文件描述符标志close-on-exec为进程和文件描述符私有，对其修改不会影响同一或不同进程的其他文件描述符

