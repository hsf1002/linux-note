### 第21章 信号处理函数

##### 设计信号处理函数

一般情况下，信号处理函数设计的越简单越好，这将降低引发竞争条件的风险，两种常见设计：

* 信号处理函数设置全局标志变量并退出
* 信号处理函数执行某种类型的清理动作，接着终止进程或使用非本地跳转，将控制返回到主程序的预订位置

在处理器函数执行期间，如果多次产生同类信号，那么仍然会将会将其标记为等待状态，稍后只传递一次，在信号处理函数中，并非所有系统调用和库函数都可以安全调用；如果同一进程的多个线程可以同时安全的调用某一函数，那么该函数就是可重入的，安全意味着，无论其他线程调用该函数的执行状态如何，函数都能产生预期结果

可重入和非可重入函数：

1. 更新全局变量或静态数据结构的函数是不可重入的
2. malloc函数族等和使用他们的其他库函数是不可重入的
3. 使用经静态分配的内存返回信息的函数如crypt()、getpwnam()、gethostbyname()、getservbyname()等是不可重入的
4. 将静态数据结构用于内部记账的函数如stdio库成员printf()、scanf()等会为缓冲区更新内部结构，也是不可重入的

标准的异步信号安全函数：

即当信号处理函数调用时，其实现是安全的函数，如果某一函数是可重入的，或者信号处理函数无法将其中断时，该函数就是异步信号安全的

![WechatIMG31.jpeg](https://i.loli.net/2019/12/02/94BZKrQOamoqzx7.jpg)

基本规则是在信号处理函数中，绝对不要调用不安全的函数

全局变量和sig_atomic_t数据类型：

尽管存在可重入问题，有时候仍然需要在主程序和信号处理函数之间共享全局变量，一般的设计是信号处理函数修改全局变量，主程序周期性的检查这个标志，此变量应该总是声明为volatile，防止被编译器优化到寄存器中，而sig_atomic_t可以保证原子性

```
volatile sig_atomic_t flag;
```

##### 终止信号处理函数的其他方法

1. 使用_exit ，不要使用exit，因为不安全，它会刷新stdio缓冲区
2. 使用kill发送信号杀掉进程
3. 执行非本地跳转

如果使用longjmp函数从信号处理函数中退出存在一个问题：BSD中，进入信号处理函数时，内核自动将引发调用的信号以及由act.sa_mask指定的任意信号添加到进程的信号掩码中，并在处理函数正常返回时再将它们从掩码中删除；System V以及Linux中，退出信号处理函数时longjmp不会将信号掩码恢复（通常这并不是希望的行为），鉴于此，POSIX定义了两个新函数，针对执行非本地跳转时对信号掩码进行显示控制：

```
#include <setjmp.h>

int sigsetjmp(sigjmp_buf env, int savemask);
// 若直接调用则返回0，若从siglongjmp调用返回则返回非0值

void siglongjmp(sigjmp_buf env, int val);

// 若savemask非0，则sigsetjmp在env中保存进程的当前信号屏蔽字，调用siglongjmp从其中恢复保存的信号屏蔽字
// 若savemask是0，则不会保存和恢复进程的信号屏蔽字
```

4. 使用abort终止进程并产生核心转储文件

```
#include <stdlib.h>

void abort(void);
// 将SIGABRT信号发送给调用进程，进程不应忽略此信号，此信号的默认动作是终止进程并产生核心转储文件
// 无论忽略或阻塞SIGABRT信号，abort调用都不受影响，除非进程捕获此信号后信号处理函数尚未返回，否则必须终止进程
```

