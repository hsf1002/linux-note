## 第44章 管道和FIFO

### 概述

##### 管道是一个字节流

没有消息边界概念，可以读取任意大小数据，通过管道传递的数据时顺序的，读出来的字节顺序与写入的顺序一致，无法使用lseek随机访问

##### 管道是单向的

在管道中数据的传递方式是单向的，一端用于写入，一端用于读取

##### 管道的容量是有限的

管道其实是内核内存中维护的缓冲器，其存储能力有限

##### 从管道读取数据

管道为空，则读取一直阻塞直到有数据写入，如管道的写入端关闭了，读取剩余数据后文件会结束（read返回0）

##### 向管道写入数据

如果多个进程同时写入同一个管道，如果同一时刻写入的数据量不超过PIPE_BUF字节，可以确保写入的数据不会发生混合的情况，SUSv3要求PIPE_BUF至少为`_POSIX_PIPE_BUF`，可通过fpathconf(fd, _PC_PIPE_BUF)确认，如果写入数据量大于PIPE_BUF，可能与其他进程写入的数据交叉；当只有一个进程写入数据时，该取值就无更重要了

### 创建和使用管道

```
#include <unistd.h>
int pipe(int fd[2]);
// 若成功，返回0，若出错，返回-1
// 若成功，fd[0]：读取端，fd[1]：写入端

#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
int pipe2(int pipefd[2], int flags);
// 若成功，返回0，若出错，返回-1
// 支持三个标记：O_CLOEXEC，O_DIRECT，O_NONBLOCK
```

管道在单个进程中用途不多，父子进程同时从管道读取和写入的做法也不常见（简单的做法是创建两个管道，不过要考虑死锁情形）；通常是fork之后，一个进程关闭读端，一个进程关闭写端

##### 管道允许相关进程间的通信

相关：指的是这两个进程具有相同的祖先

例外：通过UNIX domain socket传递管道的文件描述符

##### 关闭管道未使用的文件描述符

读取数据的进程应该关闭管道的写端，这样当其他进程完成输出关闭写端时，读取数据的进程就能知道文件结束（read返回0），否则read会一直阻塞，因为内核知道管道的写端文件描述符依然打开着

写入数据的进程应该关闭管道的读端，是处于不同的原因，如果未关闭，即使在其他进程已经关闭了管道的读端，写入数据依然能够成功，最后写入进程会将数据充满整个管道，后续写入请求被永远阻塞

只有当所有引用管道的文件描述符被关闭之后，才会销毁该管道占用的资源