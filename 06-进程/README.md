### 第6章 进程

##### 进程号和父进程号

```
#include unistd.h>

pid_t getpid(void);
// 返回值：总是成功返回进程号
```

Linux内核限制进程号需小于等于32767（由PID_MAX定义，可通过/proc/sys/kernel/pid_max文件进行调整），新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用，每当进程号达到32767时，内核将重置进程号计数器（重置为300，而不是1，小于此值得进程号为系统进程或守护进程长期占有），以便从最小整数开始分配

```
#include unistd.h>

pid_t getppid(void);
// 返回值：总是成功返回父进程号
```

每个进程都有父进程，以此类推，直到回溯到1号进程-init进程，即所有进程的始祖，如果子进程的父进程终止，子进程就会变成“孤儿”，init进程随即收养该进程，变成其父进程

##### 进程内存布局

图中的读写段包括：初始化数据段和非初始化数据段

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572747969338&di=7eaececaf570a17a0a975a7a1b6e3493&imgtype=0&src=http%3A%2F%2Fhiphotos.baidu.com%2Flongzuo%2Fpic%2Fitem%2Fc7674ea7d933c8951320f8c8d11373f0830200ee.jpg)

* 文本段包含了进程运行的程序机器语言指令
* 初始化数据段包含显式初始化的全局变量和静态变量
* 未初始化数据段包含未进行显式初始化的全局变量和静态变量
* 栈是动态增减的段，由栈帧组成，栈帧中保存着函数的局部变量、实参和返回值
* 堆是可在运行时进行内存分配的一块区域，顶端称为program break

size命令可以显示二进制可执行文件的文本段、初始化数据段、非初始化数据段的大小

3个全局符号etext、edata和end分别表示文本段、初始化数据段和非初始化数据段结尾处下一个字节的地址

##### 虚拟内存管理

Linux像多数现代内核一样，采用虚拟内存管理技术，该技术利用大多数程序的特征，即访问局部性以求高效使用CPU和RAM

* 空间局部性：程序倾向于访问最近访问过的内存地址附近的内存
* 时间局部性：程序倾向于在不久再次访问刚刚访问过的内存

进程的有效虚拟地址范围在其生命周期内可以发生变化，如：

* 由于栈向下增长超出之前到达的位置
* 堆中分配或释放内存时，通过brk、sbrk或malloc函数族提升program break的位置
* 调用shmat连接System V共享内存区时，或当调用shmdt脱离共享内存区时
* 调用mmap创建内存映射或调用munmap解除内存映射时

虚拟内存的实现需要硬件中分页内存管理单元（PMMU）的支持，虚拟地址空间与物理地址空间隔离，有很多好处：

* 进程与进程，进程与内核相互隔离，所以一个进程不能读取或修改另一个进程或内核的内存
* 适当情况下，两个或更多进程能够共享内存，由于内核可以使不同进程的页表条目指向相同的RAM页
* 便于实现内存保护机制
* 程序员和编译器、链接器之类的工具无需关注程序在RAM的物理布局
* 需要驻留到内存的只是程序的一部分，程序的加载和运行都很快，一个进程所占用的内存（虚拟内存）能够超出RAM容量

##### 栈和栈帧

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572751759031&di=18a2dd4e8b543dbb247953eccc6cb1dd&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D1180818649%2C2062788229%26fm%3D214%26gp%3D0.jpg)

内核栈是每个进程保留在内核内存中的内存区域，在执行系统调用的过程中供内部函数调用使用

用户栈包括如下信息：

* 函数实参和局部变量
* 函数调用的链接信息，如CPU寄存器

