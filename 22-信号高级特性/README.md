### 第22章 信号：高级特性

##### 核心转储文件

特定信号会引发进程创建一个核心转储文件并终止运行，核心转储文件时内含进程终止时内存映像的文件（core是一种老迈的内存技术），通常是键入退出符（Control + \）而生成SIGQUIT信号，Linux下可以使用gdb连接一个正在运行的进程，使用gcore命令获取其core文件

不产生核心转储文件的情况：

* 进程对核心转储文件没有写权限（默认是进程当前工作目录）
* 存在一个同名、可写的普通文件，但指向该文件的（硬）链接数超过一个
* 将要创建的核心转储文件所在目录不存在
* 把进程核心转储文件大小的资源限制（RLIMIT_CORE）置为0，shell下可通过ulimit设置
* 将进程可创建文件的大小的资源限制（RLIMIT_FSIZE）置为0
* 对进程正在执行的二进制可执行文件没有读权限（防止借助核心转储文件获取程序代码）
* 以只读方式挂载当前工作目录的文件系统，或文件系统空间已满，又或者i-node资源耗尽
* set-user-ID（set-group-ID）程序在由非文件属主（或属组）执行时，不会产生核心转储文件（借助于Linux专有调用prctl的PR_SET_DUMPABLE操作，可为进程设置dumpable标志，当非文件属主运行set-user-ID（set-group-ID）程序时，即可产生核心转储文件）

Linux特有的/proc/PID/coredump_filter，可以对写入核心转储文件的内存映射类型施以进程级控制，有4种内存映射：私有匿名映射、私有文件映射、共享匿名映射、共享文件映射，文件默认值提供了传统的Linux行为：仅对私有匿名映射和共享匿名映射进行转储

Linux特有的/proc/sys/kernel/core_pattern，可用格式化字符串为核心转储文件重命名，其默认名是core

```
%c  文件大小的资源软限制
%e  可执行文件名
%g  遭转储进程的实际组ID
%h  主机系统的名称
%p  遭转储进程的进程ID
%s  导致进程终止的信号编号
%t  转储时间
%u  遭转储进程的实际用户ID
%%  单个%字符
```

##### 传递、处置和处理的特殊情况

SIGKILL和SIGSTOP的默认行为是终止和停止一个进程，无法改变，如果试图使用signal或sigaction改变，总是返回错误，也不能阻塞这两个信号，这意味着总是可以使用它们终止或停止一个失控进程

SIGCONT可以使某些（因接收SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU）处于停止状态的进程得以继续运行，即使该进程处于正在阻塞或忽略SIGCONT信号，如果处于停止的进程接收的是其他信号，在接收到SIGCONT恢复运行之前，信号实际上并未传递，SIGKILL属于例外

如果程序在执行时发现，已经将对由终端产生信号的处置设置为SIG_IGN（忽略），程序通常不应该试图去改变信号处置

##### 可中断和不可中断的进程睡眠状态

SIGKILL和SIGSTOP信号对进程的作用是立竿见影的，但是有限制：

* TASK_INTERRUPTIBLE：进程正在等待某一事件如等待终端输入、等待数据写入管道等，为这种状态下的进程产生信号，那么操作中断，传递来的信号将唤醒进程，用ps命令查看处于此状态的进程STAT字段标记为S
* TASK_UNINTERRUPIBLE：进程正在等待某些特定类型的事件如磁盘IO的完成，为这种状态下的进程产生信号，那么在进程结束这种状态之前，系统不会把信号传递给进程，用ps命令查看此状态进程的STAT字段标记为D
* TASK_KILLABLE：类似于TASK_UNINTERRUPIBLE，但是会在进程收到一个致命信号时将其唤醒

##### 硬件产生的信号

硬件异常可以产生SIGBUS、SIGFPE、SIGILL、SIGSEGV，调用kill也可以发送这些信号，但是很少见，正确处理硬件产生的信号方法有二：

1. 接受信号的默认行为（如终止进程）
2. 为其编写不会正常返回的处理函数如_exit或siglongjmp，确保将控制传递回主程序的某一位置

因为在硬件异常情况下，如果进程从此类信号的处理函数返回，或进程忽略或阻塞此类信号，进程的行为未定义

##### 信号的同步生成和异步生成

异步：引发信号产生的事件，其发生与进程的执行无关

同步：硬件异常导致的5种信号或进程通过raise、kill或killpg向自身发送信号

##### 信号传递的时间与顺序

同步产生的信号立即传递，异步产生的信号即使没有阻塞，在信号产生与实际传递之间可能存在一个瞬时延迟，在此期间，信号处于等待状态，内核将等待信号传递给进程的时机是：该进程正在运行，且发生由内核态到用户态的下一次切换时，这意味着在如下时刻才会传递信号：

1. 进程再次获得调度时
2. 系统调用完成时（信号的传递可能引起正在阻塞的系统调用过早完成）

如果进程使用sigprocmask解除对多个等待信号的阻塞，所有信号会立刻传递该该进程，顺序是信号的编号按升序以此传递，与信号产生的次序无关；当多个等待信号解除阻塞时，而在信号处理函数执行期间发生了内核态和用户态的切换，那么将中断此处理器函数的执行，转而去调用第二个信号处理函数

##### signal的实现及可移植性

signal在不同实现中具有不同的语义，特别是早期的实现并不可靠，这意味着：

* 刚一进入信号处理函数，会将信号处置重置为其默认行为
* 在信号处理函数执行期间，不会对新产生的信号进行阻塞

鉴于此，sigaction是建立信号处理函数的首选

