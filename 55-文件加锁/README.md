## 第55章 文件加锁

### 概述

虽然使用信号量可以完成同步，通常使用文件锁更好，因为内核能够自动将锁与文件关联起来，两种文件锁API：

* flock对整个文件加锁，源自BSD
* fcntl对一个文件区域加锁，源自System V

虽然文件锁通常与文件IO一起使用，但可以作为一项更为通用的同步技术

##### 混合使用文件锁和stdio函数

由于stdio库会在用户空间进行缓冲，在混合使用stdio函数与加锁技术时需谨慎，可以采用如下方式：

* 使用read/write取代stdio库函数执行文件IO
* 对文件加锁之后立即刷新stdio库，且在释放锁之前立即再次刷新这个流
* 使用setbuf禁用stdio缓冲

##### 劝告式和强制式加锁

* 劝告式：默认，表示一个进程可以简单地忽略另一个进程在文件上放置的锁
* 强制式：强制一个进程执行IO时要遵循其他进程持有的锁

### 使用flock加锁

```
#include <sys/file.h>

int flock(int fd, int operation);
// 若成功，返回0，若出错，返回-1
// 任意数量的进程可同时持有一个文件上的共享锁，但在同一时刻只有一个进程能够持有一个文件的互斥锁（会拒绝其他的互斥和共享请求）
// operation的取值：
LOCK_SH：共享锁
LOCK_EX：互斥锁
LOCK_UN：解锁
LOCK_NB：发起非阻塞式请求
// 默认情况下，如果另一个进程已经持有了一把不兼容的锁（只有当另一个进程持有共享锁且当前进程请求共享锁才兼容），调用会阻塞
// 不管进程对文件的访问模式是什么，都可以对其加共享锁或互斥锁
// 通过再次调用flock并将operation指定为恰当的值可以将一个既有共享锁转换为互斥锁（反之亦然），锁的转换并非原子的，会先删除既有的锁，再创建一个新锁
```

##### 锁继承与释放的语义

```
// 对fd加锁
flock(fd, LOCK_EX);
// new_fd和fd都指向同一把锁
new_fd = dup(fd);
// 通过fd解锁
flock(new_fd, LOCK_UN);  
```

```
fd1 = open("a.txt", O_RDWR);
fd2 = open("a.txt", O_RDWR);
flock(fd1, LOCK_EX);
// 阻塞
flock(fd2, LOCK_EX);  
```

```
flock(fd, LOCK_EX);
if (0 == fork())
// 释放与父进程共享的锁
    flock(fd, LOCK_UN);
```

##### flock的限制

* 只能对整个文件加锁
* 只能放置劝告式锁
* 很多NFS实现不识别flock锁

fcntl锁将弥补这些不足

